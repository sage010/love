<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>致 邓琳钰</title>
    <style>
        /* --- 页面基础样式 --- */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #050002; /* 深邃的黑红背景，比纯黑更有质感 */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* --- Canvas 画布 --- */
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            filter: contrast(1.2) brightness(1.1); /* 增强对比度 */
        }

        /* --- 中间文字的高级排版 --- */
        .center-box {
            position: relative;
            z-index: 10;
            text-align: center;
            mix-blend-mode: screen; /* 混合模式，让文字和背后的粒子融合 */
        }

        .name {
            font-family: "Noto Serif SC", "SimSun", "Songti SC", serif; /* 使用宋体/衬线体，更有书卷气 */
            font-size: 4.5rem;
            font-weight: 700;
            /* 制作流光渐变文字 */
            background: linear-gradient(135deg, #ffe6e6 0%, #ff9a9e 50%, #ff6b81 100%);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            letter-spacing: 10px; /* 增加字间距，显得大气 */
            text-shadow: 0 0 30px rgba(255, 107, 129, 0.6);
            animation: textBreath 3s ease-in-out infinite;
        }

        .subtitle {
            margin-top: 15px;
            font-family: "Arial", sans-serif;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
            letter-spacing: 6px;
            text-transform: uppercase;
            opacity: 0;
            animation: fadeIn 2s ease-out 1s forwards;
        }

        /* --- 动画定义 --- */
        @keyframes textBreath {
            0%, 100% { transform: scale(1); filter: drop-shadow(0 0 10px rgba(255, 107, 129, 0.3)); }
            50% { transform: scale(1.03); filter: drop-shadow(0 0 25px rgba(255, 107, 129, 0.6)); }
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        /* 移动端适配 */
        @media (max-width: 768px) {
            .name { font-size: 2.8rem; letter-spacing: 5px; }
        }
    </style>
</head>
<body>

    <canvas id="canvas"></canvas>
    
    <div class="center-box">
        <div class="name">邓琳钰</div>
        <div class="subtitle">MY UNIVERSE</div> 
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let particles = [];
        // 增加粒子数量以获得细腻感，但要平衡性能
        const particleCount = 1200; 

        // 颜色库：从浅粉到深红的渐变色系
        const colors = ['#ff9a9e', '#fecfef', '#ff6b81', '#fcb69f', '#ffdde1'];

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- 改进的心形函数 ---
        // 引入 scale 参数，方便动态调整大小
        function getHeartPoint(t, scale = 15) {
            const x = 16 * Math.pow(Math.sin(t), 3);
            const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
            return { x: x * scale, y: -y * scale };
        }

        class Particle {
            constructor() {
                this.reset(true);
            }

            reset(isInit = false) {
                // 随机角度
                const t = Math.random() * 2 * Math.PI;
                
                // 基础位置
                const heart = getHeartPoint(t);
                const centerX = width / 2;
                const centerY = height / 2;

                // 目标位置
                this.targetX = centerX + heart.x;
                this.targetY = centerY + heart.y;

                // 初始位置：如果是初始化，就在随机位置；如果是重置，就在中心附近喷射出来
                if (isInit) {
                    this.x = Math.random() * width;
                    this.y = Math.random() * height;
                } else {
                    this.x = centerX;
                    this.y = centerY;
                }

                // 粒子属性
                this.size = Math.random() * 2.5; // 大小不一
                this.speed = Math.random() * 0.06 + 0.02;
                this.color = colors[Math.floor(Math.random() * colors.length)];
                this.friction = Math.random() * 0.9 + 0.1; // 摩擦力系数，制造层次
                
                // 偏移量：让粒子不要死死粘在线上，而是形成光晕带
                this.offsetX = (Math.random() - 0.5) * 20; 
                this.offsetY = (Math.random() - 0.5) * 20; 
            }

            update(beatScale, time) {
                // 目标位置加上心跳缩放
                const centerX = width / 2;
                const centerY = height / 2;
                
                // 计算当前的理想位置
                // 我们保留原始的 targetX/Y 比例，应用 beatScale
                let targetX = centerX + (this.targetX - centerX) * beatScale + this.offsetX;
                let targetY = centerY + (this.targetY - centerY) * beatScale + this.offsetY;

                // 增加一点基于时间的浮动，像呼吸一样
                targetX += Math.sin(time * 2 + this.size) * 5;
                targetY += Math.cos(time * 2 + this.size) * 5;

                // 缓动移动
                this.x += (targetX - this.x) * this.speed;
                this.y += (targetY - this.y) * this.speed;

                // 绘制
                this.draw();
            }

            draw() {
                ctx.beginPath();
                // 绘制发光效果：画圆
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }

        function initParticles() {
            particles = [];
            for (let i = 0; i < particleCount; i++) {
                particles.push(new Particle());
            }
        }

        function animate() {
            // --- 关键点：拖尾效果 ---
            // 不完全清空画布，而是覆盖一层半透明的黑色
            // 这种 "fillStyle + fillRect" 的方式能制造出流体拖尾感
            ctx.fillStyle = 'rgba(5, 0, 2, 0.15)'; 
            ctx.fillRect(0, 0, width, height);

            const time = Date.now() / 1000;
            
            // 模拟更真实的心跳节奏：咚-咚----咚-咚
            // 使用 pow(sin) 来让波形更尖锐，模拟肌肉收缩
            let beat = Math.sin(time * 3); 
            // 让心跳有顿挫感（正值部分稍微尖锐一点）
            let beatScale = 1 + Math.pow(Math.abs(beat), 4) * 0.12;

            particles.forEach(p => p.update(beatScale, time));

            requestAnimationFrame(animate);
        }

        initParticles();
        animate();

    </script>
</body>
</html>
